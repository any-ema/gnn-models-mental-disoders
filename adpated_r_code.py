# -*- coding: utf-8 -*-
"""adpated_r_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C1Jrfjm8hyrk5Jx_m6JTJ6iSYdp1KDg0
"""

install.packages("mvtnorm")
install.packages("lme4")
install.packages("qgraph")
install.packages("arm")

library(mvtnorm)
library(lme4)
library(qgraph)
library(arm)

networkdata <- read.table(file="Data S4.txt", header=TRUE, sep=",")

head(networkdata)

addTrans <- function(color, trans) {
  if (length(color) != length(trans) & !any(c(length(color), length(trans)) == 1))
    stop("Vector lengths not correct")
  if (length(color) == 1 & length(trans) > 1) color <- rep(color, length(trans))
  if (length(trans) == 1 & length(color) > 1) trans <- rep(trans, length(color))

  num2hex <- function(x) {
    hex <- unlist(strsplit("0123456789ABCDEF", split = ""))
    return(paste(hex[(x - x %% 16) / 16 + 1], hex[x %% 16 + 1], sep = ""))
  }
  rgb <- rbind(col2rgb(color), trans)
  res <- paste("#", apply(apply(rgb, 2, num2hex), 2, paste, collapse = ""), sep = "")
  return(res)
}

lagK_data <- function(x, vv, K) {
  dimens <- dim(x)
  pp <- unique(x$subjno)
  npp <- length(pp)
  LEvv <- length(vv)
  nday <- max(x$dayno, na.rm = TRUE)

  # Criar matriz para dados lagged
  x <- cbind(x, matrix(NA, dimens[1], K * LEvv + 1))

  for (j in 1:npp) {
    for (dd in 1:nday) {
      for (ss in 0:1) {
        indices <- (x$subjno == pp[j]) & (x$dayno == dd) & (x$st_period == ss)
        uu <- x[indices, vv]

        if (nrow(uu) > 0) {
          end <- dim(uu)
          for (k in 1:K) {
            lagged_data <- rbind(
              matrix(NA, nrow = k, ncol = LEvv),
              as.matrix(uu[1:(end[1] - k), ])
            )
            x[indices, (dimens[2] + 1 + (k - 1) * LEvv):(dimens[2] + k * LEvv)] <- lagged_data
          }
          x[indices, (dimens[2] + 1 + K * LEvv)] <- c(rep(0, K), rep(1, end[1] - K))
        }
      }
    }
  }

  colnames(x)[(dimens[2] + 1):(dimens[2] + K * LEvv + 1)] <- c(
    paste(rep(vv, times = K), rep("L", K * LEvv), rep(1:K, each = LEvv), sep = ""),
    "lagK"
  )

  return(x)
}

columns <- c("opgewkt_", "onplplez", "pieker", "angstig_", "somber__", "ontspann")

networkdataL <- lagK_data(networkdata, columns, 1)
head(networkdataL)

model1 <- list()
columns <- c("opgewkt_", "onplplez", "pieker", "angstig_", "somber__", "ontspann")

pred1 <- "(opgewkt_L1 + onplplezL1 + piekerL1 + angstig_L1 + somber__L1 + ontspannL1) + st_period + (opgewkt_L1 + onplplezL1 + piekerL1 + angstig_L1 + somber__L1 + ontspannL1):st_period + st_period:informat04 + st_period:(opgewkt_L1 + onplplezL1 + piekerL1 + angstig_L1 + somber__L1 + ontspannL1):informat04 + (st_period + opgewkt_L1 + onplplezL1 + piekerL1 + angstig_L1 + somber__L1 + ontspannL1 || subjno)"

# Usar apenas uma amostra menor para demonstração no Colab
sample_data <- networkdataL[sample(1:nrow(networkdataL), 1000), ]

for (j in 1:6) {
  ff <- as.formula(paste(columns[j], "~", pred1, sep = ""))
  model1[[j]] <- lmer(ff, data = sample_data, REML = FALSE,
                      control = lmerControl(optimizer = "Nelder_Mead"))
  print(j)
}

BIC1 <- unlist(lapply(model1, BIC))
sum(BIC1)

### Inferring the coefficients or connection strengths for the network
coef1 <- data.frame(matrix(unlist(lapply(model1, fixef), use.names = FALSE), byrow = TRUE, ncol = length(fixef(model1[[1]]))))
se.coef1 <- data.frame(matrix(unlist(lapply(model1, function(x) {
  se <- tryCatch(
    se.fixef(x),
    error = function(e) rep(NA, length(fixef(x)))
  )
  return(se)
}), use.names = FALSE), byrow = TRUE, ncol = length(fixef(model1[[1]]))))

colnames(coef1) <- names(fixef(model1[[1]]))
colnames(se.coef1) <- names(fixef(model1[[1]]))
rownames(coef1) <- columns
rownames(se.coef1) <- columns

coef1

E <- cbind(from = rep(1:6, each = 6), to = rep(1:6, 6), weight = unlist(coef1[, 2:7]))
pvals <- 2 * (1 - pnorm(abs(unlist(coef1[, 2:7] / se.coef1[, 2:7]))))

# Corrigir NA nos p-values
pvals[is.na(pvals)] <- 1

edge.color <- addTrans(ifelse(E[, 3] > 0, "green3", "red3"), ifelse(pvals < 0.05, 255, 50))

# No Colab, podemos visualizar diretamente
qgraph(E, fade = FALSE, layout = "circular",
       labels = c("C", "E", "W", "F", "S", "R"),
       lty = ifelse(E[, 3] > 0, 1, 5),
       edge.labels = FALSE,
       edge.color = edge.color,
       title = "Figure 1: Population Network")

E